# nCells=75診断結果（最終）

**実行日:** 2025-10-27
**設定:** moderate profile (1.5×, 1.2×), nCells=75, dt=1.5e-4, tolerance=1e-1

---

## 🔬 重要な発見

### 1. Jacobian条件数は3パターン中最良 ✅

```
κ = 3.36e+04 (全イテレーションで一定)
σ_max = 3.52e+07
σ_min = 1.05e+03
```

**比較:**
- nCells=50: κ = 4.2e+04
- **nCells=75: κ = 3.36e+04** ← 最良
- nCells=100: κ = 6.5e+05

**結論:** 中間解像度が条件数の最適点

---

### 2. 初期収束は順調だが、iter=6以降完全停滞 ⚠️

#### residualNormの推移

| iter | residualNorm | improvement | α | 評価 |
|------|-------------|-------------|---|------|
| 0 | 2.03 → 0.510 | +74.9% | 1.0 | ✅ 大幅改善 |
| 1 | 0.510 → 0.478 | +6.2% | 0.25 | ✅ 改善継続 |
| 2-4 | 0.478 → 0.478 | 0.0% | 0.25 | ⚠️ 一時停滞 |
| 5 | 0.478 → 0.462 | +3.3% | 0.25 | ✅ 再び改善 |
| **6-12** | **0.462** | **0.0%** | 0.25 | ❌ 停滞開始 |
| **13-15** | **0.462** | **0.0%** | 0.1 (fallback) | 🔴 完全停滞 |

**現在の状態:**
- residualNorm = 0.462 (固定)
- tolerance = 0.1 (目標)
- **ギャップ: 4.62倍**

---

### 3. iter=13で計算時間が異常増加 🔴

| iter | Jacobian計算時間 | vjp平均時間 | 備考 |
|------|-----------------|-------------|------|
| 0-12 | 15-17秒 | 0.05秒 | 正常 ✅ |
| **13** | **64.43秒** | **0.21-0.24秒** | **4倍増加** 🔴 |
| 14 | 38.25秒 | 0.22-0.27秒 | 依然遅い |
| 15 | (進行中) | 0.05秒 | 一部正常化 |

**これはnCells=100のiter=3と同じ現象（90秒超）**

**推定原因:** MLXグラフの蓄積（eval()呼び出し不足の可能性）

---

### 4. Line Searchの完全失敗（iter=13-15） ❌

#### iter=13の詳細

```
initialNorm = 4.62e-01

α=1.000: residualNorm=5.55e-01, improvement=-19.9% (悪化)
α=0.500: residualNorm=5.40e-01, improvement=-16.8% (悪化)
α=0.250: residualNorm=4.63e-01, improvement=-0.1% (悪化)
α=0.125: residualNorm=4.62e-01, improvement=0.0% (変化なし)
α=0.062以下: すべて0.0% (変化なし)

❌ FAILED: All 10 attempts failed to reduce residual
Returning fallback α=0.1
```

**iter=14も同一パターン** → nCells=50のiter=3以降と同じ

---

### 5. deltaScaledの消失 🔴

```
iter=0:  ||Δ|| = 2.17e-04  ✓ 正常
iter=1:  ||Δ|| = 8.35e-07  ✓ 減少だが健全
iter=5:  ||Δ|| = 2.70e-07  ✓ 健全
iter=13: ||Δ|| = 7.67e-08  🔴 浮動小数点ノイズレベル
iter=14: ||Δ|| = 7.46e-08  🔴 ほぼ同じ（変化なし）
```

**Newton補正ベクトルがほぼゼロ = Newton法が方向を見失っている**

---

## 📊 3パターン全体の比較と最終結論

### 比較表

| 項目 | nCells=50 | nCells=75 | nCells=100 |
|------|-----------|-----------|------------|
| **Jacobian条件数 (κ)** | 4.2e+04 | **3.36e+04** ✅ | 6.5e+05 ❌ |
| **停滞値 (residualNorm)** | 0.475 | **0.462** | 0.463 |
| **tolerance=0.1到達** | ❌ (4.75倍) | ❌ (4.62倍) | ❌ (4.63倍) |
| **停滞開始イテレーション** | iter=3 | iter=6 | なし（遅延のみ） |
| **計算時間/iter（正常時）** | 10秒 | 16秒 | 20秒 |
| **計算時間異常** | なし | iter=13: 64秒 | iter=3: 90秒 |
| **Line search α（停滞時）** | 0.1 (fallback) | 0.1 (fallback) | 0.002-0.0625 |
| **deltaScaled（停滞時）** | 2.88e-08 | 7.67e-08 | 4.24e-07 |
| **総合評価** | 離散化誤差大 | 中間値だが不十分 | 条件数悪化で遅い |

---

## 🎯 根本原因の特定：メッシュ解像度では解決不可

### 共通の問題点

**すべてのメッシュ解像度（50, 75, 100）で以下が共通:**

1. **residualNorm ≈ 0.46-0.48 で停滞**
   - これは物理的/数値的な「壁」
   - メッシュを変えても大きく改善しない（±3%程度）

2. **Newton方向の消失**
   - deltaScaledが10^-8レベルまで低下
   - Jacobianは健全（κ < 10^5）だが、方向が不正確

3. **Line searchで改善不可能**
   - α=1.0: 大幅悪化（-15%～-20%）
   - α<1.0: 変化なし（±0.0%）
   - Newton方向そのものが誤り

### 離散化誤差 vs 条件数のジレンマ

```
粗いメッシュ (nCells=50):
  ✅ 条件数良好 (κ=4.2e+04)
  ❌ 離散化誤差大 (dr=0.04m)
  → residualNorm=0.475で停滞

中間メッシュ (nCells=75):
  ✅ 条件数最良 (κ=3.36e+04)
  ⚠️  離散化誤差中程度 (dr=0.027m)
  → residualNorm=0.462で停滞（わずかに改善）

細かいメッシュ (nCells=100):
  ✅ 離散化誤差小 (dr=0.02m)
  ❌ 条件数悪化 (κ=6.5e+05, 15倍!)
  → residualNorm=0.463で非常に遅い収束
```

**どのメッシュでも tolerance=0.1 (residualNorm < 0.1) には到達できない**

---

## 💡 根本的解決策：Preconditioner実装

### 現状の問題

**moderate初期プロファイル (Ti: 1000→1500 eV, ne: 2.0e19→2.4e19 m^-3) では:**

- 変数スケールが不均一:
  - Ti/Te: O(1000) eV
  - ne: O(10^19) m^-3
  - psi: O(?) (未使用だが存在)

- Jacobianの各行/列が異なるスケール
  - dF_Ti/dTi: O(10^22) / O(1000) = O(10^19)
  - dF_ne/dne: O(10^22) / O(10^19) = O(10^3)
  - **スケール差: 10^16倍**

- Newton方向が物理的に不正確
  - 大きなスケールの変数が支配的
  - 小さなスケールの変数が無視される

### Preconditioner（前処理）の原理

**変数ごとに異なるスケーリングを適用してJacobianを正規化:**

```
現在（スケーリングなし）:
  J * Δx = -R

Preconditioner適用後:
  (P^-1 * J) * (P * Δx) = -P^-1 * R

ここで P = diag(referenceState):
  P_Ti(i) = Ti_ref[i] (各セルの参照温度)
  P_Te(i) = Te_ref[i] (各セルの参照温度)
  P_ne(i) = ne_ref[i] (各セルの参照密度)
```

**すべての変数が同じオーダー（O(1)）になる**

### 期待される効果

1. **条件数の劇的改善**
   - κ = 3.36e+04 → **1e+03程度**（1-2桁改善）
   - σ_min が大きくなる

2. **Newton方向の正確化**
   - 変数間のバランスが取れる
   - 小スケール変数も適切に更新される

3. **収束速度の向上**
   - α=1.0で改善する可能性
   - Line searchの成功率向上

4. **tolerance=0.1到達可能**
   - 現在の4.62倍のギャップを克服
   - residualNorm < 0.1 への道が開ける

---

## 📋 推奨する実装戦略

### Phase A: Diagonal Preconditioner実装（最優先）

**目的:** 変数スケールの不均一性を根本的に解決

**実装場所:** `NewtonRaphsonSolver.swift`

**実装内容:**
1. `referenceState`から対角Preconditioner `P`を作成
2. Jacobianを列スケーリング: `J_precond = J * diag(1/P)`
3. 残差をスケーリング: `R_precond = R / P`
4. 線形ソルバー: `Δ_precond = solve(J_precond, -R_precond)`
5. 元のスケールに戻す: `Δ = Δ_precond / P`

**期待される結果:**
- κ: 3.36e+04 → 1e+03
- residualNorm: 0.462 → < 0.1 (収束)
- Line search α: 0.1 → 1.0 (健全化)

**実装の複雑さ:** 中程度（50-100行）

**推定実装時間:** 1-2時間

---

### Phase B: tolerance緩和（一時的措置、並行実施可能）

**目的:** Preconditioner実装までの診断継続

**実装場所:** `SimulationPresets.swift:103`

```swift
tolerance: 2e-1,  // 1e-1 → 2e-1
```

**期待される結果:**
- residualNorm=0.462 で「収束」判定される
- シミュレーションが完走する
- プロファイルの妥当性を評価可能

**注意:** これは一時的措置であり、物理的精度は低下

---

### Phase C: 適応dtのさらなる削減（診断用）

**目的:** 非線形性の緩和効果を確認

**実装場所:** `SimulationPresets.swift:82`

```swift
builder.time.initialDt = 1.0e-4  // 1.5e-4 → 1.0e-4
```

**期待される結果:**
- 1ステップあたりの変化量が小さくなる
- Newton収束が改善する可能性

**注意:** 総ステップ数が1.5倍に増加（計算時間増）

---

### Phase D: MLXグラフ蓄積の調査（副次的）

**目的:** iter=13での計算時間異常増加の原因究明

**実装場所:** `NewtonRaphsonSolver.swift` (vjpループ内)

**仮説:** eval()呼び出しが不足している箇所がある

**調査方法:**
1. vjpループ内の各配列に対して明示的にeval()
2. イテレーションごとの計算時間を詳細ログ
3. MLX.graphSize()などのメトリクスを追跡（もしあれば）

**優先度:** 低（収束問題の解決後）

---

## 🔍 最終結論

### nCells=75の評価

✅ **成功した点:**
- Jacobian条件数が3パターン中最良（κ=3.36e+04）
- 初期収束は最も順調（iter=0-5）
- nCells=50より低い停滞値（0.462 vs 0.475、3%改善）

❌ **失敗した点:**
- tolerance=0.1に到達不可（4.62倍のギャップ）
- iter=6以降完全停滞
- iter=13で計算時間異常増加（64秒）
- メッシュ解像度だけでは根本的解決にならないことが確定

### 全体の結論

**メッシュ解像度の調整（50, 75, 100）だけでは、Newton-Raphson法の収束問題は解決できない。**

**根本原因:**
1. 変数スケールの不均一性（Ti: O(1000), ne: O(10^19)）
2. Jacobianのスケーリング不良
3. Newton方向の不正確さ

**必須の実装:**
- **Diagonal Preconditioner** によるJacobianの正規化

**代替策（推奨されない）:**
- Trust-Region法への置き換え（大規模リファクタリング）
- ソルバー自体の変更（GMRES, BiCGSTABなど）

---

## 📝 次のアクション

### 優先順位1: Preconditioner実装

`PRECONDITIONER_IMPLEMENTATION_STRATEGY.md` を参照して実装を開始

### 優先順位2: tolerance=0.2へ一時緩和

Preconditioner実装中でも診断を継続できるようにする

### 優先順位3: ドキュメント更新

- `SimulationPresets.swift` のコメント更新
- `PHASE_MIGRATION_GUIDE.md` の修正

---

**最終更新:** 2025-10-27
**ステータス:** nCells=75でも収束不可、Preconditioner実装が必須
**次のステップ:** Phase A (Diagonal Preconditioner) の実装
